/**
 * Created by samueldoyle
 * For some methods to be used during the build process
 * TODO: ATM this adds closures to the VMWARE_CONF properties should be a plugin or something for utility methods, change later
 */
import groovy.swing.SwingBuilder
import java.awt.*
import org.apache.tools.ant.filters.ReplaceTokens

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath "com.google.guava:guava:$guavaVersion"
        classpath "org.apache.commons:commons-lang3:$commonsLangVersion"
    }
}

/**
 * Collects user input via swing dialog for scaffold app
 * @param app
 */
VMWARE_CONF.promptNewAppProperties = { app ->

    def modFieldConverter = { modField ->
        modField.toLowerCase()
    }

    def modFieldValidator = { modField ->
        modField ==~ /.*?[\.a-zA-Z].*?/
    }

    new SwingBuilder().edt {
        lookAndFeel "nimbus"
        dialog(modal: true,
            title: "Project Properties",
            alwaysOnTop: true,
            resizable: true, // Don't allow the user to resize the dialog
            locationRelativeTo: null, // Place dialog in center of the screen
            pack: true, // We need to pack the dialog (so it will take the size of it's children)
            show: true // Let's show it
        ) {
            borderLayout(vgap: 5)
            panel(constraints: BorderLayout.CENTER,
                border: compoundBorder([emptyBorder(10), titledBorder("Enter New Application Properties:")])) {
                tableLayout {
                    tr {
                        td {
                            label "Mod Owner ('com.' will be prefixed):"
                        }
                        td {
                            textField id: "modOwnerField", columns: 20, text:bind(
                                validator: modFieldValidator,
                                converter: modFieldConverter,
                                target:app, targetProperty:'modOwner'
                            )
                        }
                    }
                    tr {
                        td {
                            label "Mod Name:"
                        }
                        td {
                            textField id: "modNameField", columns: 20, text:bind(
                                validator: modFieldValidator,
                                converter: modFieldConverter,
                                target:app, targetProperty:'modName'
                            )
                        }
                    }
                }
            }

            panel(constraints: BorderLayout.SOUTH) {
                button text: "Build", actionPerformed: {
                    app.doBuild = true
                    app.modOwner = "com.${app.modOwner}"
                    dispose()
                }
                button text: "Cancel", actionPerformed: {
                    dispose()
                }
            }
        }
    }
}

/**
 * Generates a target dir for output, simply increments a number to add to the outputdir if it exists already
 * @param genDirBase - the base dir to check and increment if exists e.g. /tmp/foo-bar-service
 * @return - A file representing the chosen directory
 */
VMWARE_CONF.genAppOutDir = { genDirBase ->
    def genDirInc = -1, targetOutDir, first = true
    while (true) {
        if (first) {
            targetOutDir = new File("${genDirBase}")
        } else {
            targetOutDir = new File("${genDirBase}.${genDirInc}")
        }
        if (targetOutDir.exists()) {
            genDirInc++
            continue
        }
        break
    }

    targetOutDir
}

/**
 * Outputs a scaffolded app based on provided properties
 * @param props - required properties to output the scaffold
 */
VMWARE_CONF.scaffoldApp = { props ->
    def scaffoldSvcDir = "$props.scaffoldDir/scaffold-service",
        scaffoldRscDir = "$props.scaffoldDir/scaffold-artifacts/scaffold-resources",
        scaffoldSrcDir = "$props.scaffoldDir/scaffold-artifacts/scaffold-src",
        scaffoldGroovySrcDir = "$scaffoldSrcDir/groovy"

    copy {
        from(scaffoldSvcDir) {
            exclude "**/gradle.properties", "**/mod.json", "**/index.html"
        }
        // this filter is for replacing the vertx modname and modowner for the module, this is provided through
        // the user input
        from(scaffoldSvcDir) {
            include "**/gradle.properties"
            include "**/mod.json"
            include "**/index.html"
            filter(ReplaceTokens, tokens: props.replaceTokens)
        }
        into props.targetOutDir.absolutePath
        includeEmptyDirs = true
    }

    def webUiDir = "$props.targetOutDir.absolutePath/web-ui",
        modDir = "$webUiDir/app/modules",
        srcDir = "$props.targetOutDir.absolutePath/src",
        groovyDir = "$srcDir/main/groovy"

    // Create a custom mod dir alongside common
    File scaffModDir = new File(modDir, props.replaceTokens.modName)
    assert scaffModDir.mkdirs()
    ["controllers", "services", "views"].each {
        assert new File(scaffModDir, it).mkdirs()
    }

    copy {
        from(scaffoldRscDir) {
            rename { String fileName ->
                fileName.replace("scaffold", props.replaceTokens.modName)
            }
            filter(ReplaceTokens, tokens: props.replaceTokens)
        }
        into scaffModDir.absolutePath
    }

    // Create groovy src directory structure
    def groovySrcOut = props.replaceTokens.modOwner.replaceAll(/\./, "/")
    File groovySrcDirs = new File("$groovyDir/$groovySrcOut")
    assert groovySrcDirs.mkdirs()
    File groovyHelpersDirs = new File(groovySrcDirs, "helpers")
    assert groovyHelpersDirs.mkdir()

    copy {
        from(scaffoldGroovySrcDir) {
            rename { String fileName ->
                fileName.replace("Scaffold", props.serviceBaseName)
            }
            filter(ReplaceTokens, tokens: props.replaceTokens)
        }
        into groovySrcDirs.absolutePath
    }


    println "INFO: App Generated --> ${props.targetOutDir.absolutePath}"
}
