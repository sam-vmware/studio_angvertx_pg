import com.google.common.base.CharMatcher
import org.apache.commons.lang3.text.*

// Some global conf to share around projects
ext.VMWARE_CONF = [
    vertx: [
        // Change this to the lib directory of where your Vert.x build lib directory is
        libDir   : "${System.env.VERTX_HOME}/lib",
        // Additional jar dependencies
        // !! IMPORTANT !!
        // The vertx lang-groovy-xxx*.jar is in here and MUST MATCH the
        // the mod version you use if you are doing a custom vertx build.
        // this is the version that gets placed in your $VERTX_MODS directory
        addedLibs: "$rootDir/shared/common/added_libs"
    ]
]

apply from: "$rootDir/gradle/vmware_methods.gradle"

task wrapper(type: Wrapper) {
    gradleVersion = buildGradleVersion
}

configurations.all {
    resolutionStrategy {
        // fail eagerly on version conflict (includes transitive dependencies)
        // e.g. multiple different versions of the same dependency (group and name are equal)
        failOnVersionConflict()

        // force certain versions of dependencies (including transitive)
        //  *append new forced modules:
        force "org.codehaus.groovy:groovy-all:$groovyVersion"
        //  *replace existing forced modules with new ones:
        forcedModules = ["org.codehaus.groovy:groovy-all:$groovyVersion"]

        // add a dependency resolve rule
        eachDependency { DependencyResolveDetails details ->
            //changing 'groovy-all' into 'groovy':
            if (details.requested.name == 'groovy-all') {
                //details.useTarget group: details.requested.group, name: 'groovy', version: details.requested.version
                details.useTarget group: details.requested.group, name: 'groovy-all', version: "$groovyVersion"
            }
        }

        // cache dynamic versions for 10 minutes
        cacheDynamicVersionsFor 10 * 60, 'seconds'
        // don't cache changing modules at all
        cacheChangingModulesFor 0, 'seconds'
    }
}

/*
gradle.taskGraph.whenReady { taskGraph ->
    if (taskGraph.hasTask(':createApp')) {
    }
}
tasks.whenTaskAdded { task ->
    if (task.name == 'modZip') {
        task.dependsOn copyWebUI
    }
}
configure(subprojects.findAll {it.tasks.findByPath('modZip')}) {
}
*/

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath "org.codehaus.groovy:groovy-all:$groovyVersion"
        classpath "com.google.guava:guava:$guavaVersion"
        classpath "org.apache.commons:commons-lang3:$commonsLangVersion"
    }
}

allprojects {
    apply plugin: 'java'
    apply plugin: 'groovy'

    sourceCompatibility = buildSourceCompatibility
    buildTargetCompatibility = targetCompatibility
    group = buildGroup
    version = buildVersion

    repositories {
        mavenCentral()
    }

    dependencies {
        compile "org.codehaus.groovy:groovy-all:$groovyVersion"
        compile "com.google.guava:guava:$guavaVersion"
    }
}

subprojects {
    afterEvaluate { project ->
        /*  def modZipTask = project.tasks.findByPath('modZip')
            if (modZipTask) {
                println "Project: ${project.name} has modZipTask: $modZipTask"
                project.task(name: copyWebUI, type: Copy, dependsOn: modZipTask) << {
                    from("web-ui/app")
                    into("build/mods/$moduleName")
                    outputs.upToDateWhen { false }
                }
            }*/
        // Inject test configuration into all subprojects
        test {
            // See http://www.gradle.org/docs/current/dsl/org.gradle.api.tasks.testing.Test.html for more settings
            systemProperty 'env', 'test'
        }
    }
}

/************************** TASKS **************************/

/*task copyWebUI(type: Copy, dependsOn: 'modZip', description: 'Copy static content') {
    if (project.hasProperty('moduleName')) {
        from 'web-ui/app'
        into "build/mods/$moduleName"
        outputs.upToDateWhen { false }
    }
}*/

task createApp << {
    file("$rootDir/gradle.properties").withReader { reader ->
        def theProps = new Properties()
        theProps.load(reader)
        properties.putAll(theProps)
    }

    // Some default values for sample
    def scaffoldDir = "$rootDir/scaffolding"
    def genDirBase = "$scaffoldDir/generated"
    def copyDirBase = "$scaffoldDir/scaffold-service"

    File copyDirBaseDir = new File(copyDirBase)
    if (!copyDirBaseDir.exists() || !copyDirBaseDir.isDirectory()) {
        println "ERROR: Missing scaffold-service directory, expected location --> ${copyDirBaseDir.absolutePath}"
        System.exit(1)
    }

    // SwingBuilder generated dialog to gather required properties
    def app = VMWARE_CONF.promptNewAppProperties()
    println "\nINFO: App collected values: $app\n"

    // Get a directory to output the scaffold app
    String genDirOut = "$genDirBase/scaffold-$app.modName"
    String targetOutDir = VMWARE_CONF.genAppOutDir(genDirOut)
    println "DEBUG: targetOutDir : $targetOutDir"

    // def convertedModName = CharMatcher.JAVA_LETTER.retainFrom(app.modName)
    // def convertedModOwner = CharMatcher.JAVA_LETTER.retainFrom(app.modOwner)
    String serviceBaseName = "${WordUtils.capitalize(app.modName)}"
    String serviceName = "${serviceBaseName}Service"
    String serviceHelperName = "${serviceName}Helper"

    def replaceTokens = [
        modName         : app.modName as String,
        modOwner        : app.modOwner as String,
        buildVersion    : buildVersion,
        serviceName: serviceName as String,
        serviceHelperName: serviceHelperName as String
    ]
    // All the properties needed
    def scaffoldProperties = [
        scaffoldDir  : scaffoldDir as String,
        targetOutDir : targetOutDir as String,
        serviceBaseName: serviceBaseName as String,
        replaceTokens: replaceTokens
    ]

    // If ok selected from the properties gui scaffold the app
    if (app.doBuild) {
        println "DEBUG: Using scaffoldProperties : $scaffoldProperties"
        VMWARE_CONF.scaffoldApp(scaffoldProperties)
    }
}

task(console, dependsOn: 'classes', type: Exec) {
    def cp = sourceSets.main.runtimeClasspath.filter {
        !it.name.contains("groovy-all")
    }
    cp += files("$rootDir/classes/production/common")

    def jars =
        files(fileTree(dir: VMWARE_CONF.vertx.libDir, includes: ['*.jar'])) +
            files(fileTree(dir: VMWARE_CONF.vertx.addedLibs, includes: ['*.jar']))
    environment["JARS_TO_ADD"] = jars.getAsPath()

    def consoleCP = cp + jars
    //commandLine '/usr/bin/env', 'groovyConsole', '--classpath', cp.getAsPath()
    commandLine "${VMWARE_CONF.groovyConsolePath}", '--classpath', consoleCP.getAsPath()
    ignoreExitValue true
}

